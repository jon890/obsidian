
## 2장. 느려진 서비스, 어디부터 봐야할까

- 파일을 읽을 때에는 스트림을 사용하여, 메모리를 최적화 하자
- 응답 데이터 압축
	- gzip
	- brotli (?)
	- Accept-Encoding 헤더에 압축 알고리즘 정의
- 정적 자원 캐시
	- Cache-Control 헤더에 명시
		- 유저의 로컬 캐시에 보관

## 3장.  성능을 좌우하는 DB 설계와 쿼리

- 게시물 본문 검색은 어떻게 구현하는게 좋을까?
	- MySQL FULLTEXT 인덱스 고려
		- ElasticSearch까지 부담될 때..
- 인덱스는 고유한 값이 적은것으로 하는게 좋다.
	- 일자별 데이터는 많아질경우에 월별 파티셔닝 고려
- 게시글 좋아요 수, 조회 수는 어떻게 집계하는게 좋을까?
	- 게시글 Post에 Pessimistic Lock을 잡는방법은 별로 좋지 않은 듯하고
	- 낙관적으로 Locking을 사용하여 좋아요 수를, 늘리고 계속하여 재시도하는 방식으로 처리하는게 낫지 않을까?

- APM 사용
	- 응답 시간 분포를 시각적으로 표시

- 오래된 데이터 삭제 및 분리 보관
	- MySQL에도 단편화가 발생하나?

- 쿼리 타임아웃 설정
	- JPA에서 어떻게 처리?

- SELECT를 반드시 Replica에서 읽으면 안되는 경우도 처리해야한다
	- 상태 변경이 일어난 데이터를 Replica에서 처리할 경우 곤란해질 수 있음
	- 데이터 정합성 불일치

- 타입이 다른 컬럼 조인 주의
	- 게임 도메인에선 그럴일이 거의 없긴 했는데.. 테이블 설계가 잘못된 건 아닐까

- MySQL 테이블 변경
	- 새 테이블 생성
	- 원본 테이블의 데이터 복사
	- 새 테이블로 대체
		- 이 정도로 변경되는 데이터는 미리 수행시간을 측정해서 처리를 고민할듯
		- 테이블 변경에 대한 수행시간 측정은 어떻게 하지?
		- 테이블 변경이 너무 오래걸린다면 중간에 취소해도 괜찮나?
			- 위 흐름이면 가능해보인다..

- 적절한 DB 커넥션 수는?
	- 소켓통신을 위한 소켓을 열어야하는 것이므로 관련된 자원을 안정적으로 유지할 정도만..?

## 4장. 외부 연동이 문제일 때 살펴봐야 할 것들

- 연동하는 서비스에 장애가 발생하면 우리 서비스도 영향을 받는다
	- 완전히 차단하기는 어려우나, 영향을 줄이는 방법을 고민해볼 수 있다.
	- 타임아웃
		- 타임아웃이 발생했으나, 정상적으로 처리되버린 경우는 어떻게..?
		- 연결 타임아웃
			- 3 ~ 5초
		- 읽기 타임아웃
			- 5 ~ 30초 정도 설정하면서 추이를 보자
	- 재시도
		- 단순 조회 기능
		- 연결 타임아웃
		- 멱등성을 가진 변경 기능
			- 멱등성 키등을 통해서, 이미 변경된 값이면 캐쉬된 응답을 내려준다거나.. 처리되있는 경우에만 가능
		- 1~2번 정도의 재시도가 적절
			- 아무리 재시도해도 성공하지 못할 수도 있으므로..
			- 근본적인 문제를 해결하는게 좋다.
	- 연동 서비스가 받아낼 수 있는 요청 수보다 많이 요청하지 않고 에러리턴
		- 503 - 서비스 일시적 장애 에러 코드 
		- 벌크헤드 패턴
	- 서킷 브레이커
		- 닫힘 - 서비스 가능 상태
		- 열림 - 에러 상태
		- 반열림 - 에러 상태에서 어느정도 지나면 반열림 상태가 됨, 일부 요청에 한해 시도
			- 해당 기간동안 성공 시, 닫힘 상태가 됨
			- fast fail

- 외부 연동과 DB 연동
	- 외부 연동 실패 => 트랜잭션 롤백
	- 외부 연동 성공 but DB 연동 실패 => 트랜잭션 롤백

- 트랜잭션을 롤백했는데, 외부 서비스가 실제로 성공
	- 일정 주기로 데이터가 일치하는지 확인 후 보정
	- 성공 확인 API 호출 or 취소 API 호출 (보상 트랜잭션?)
		- 이 API 호출에도 타임아웃이 발생할 수 있음을 고려해야 함

- 외부 연동이 느려질 때 DB 커넥션 풀 문제
	- 외부 연동과 트랜잭션이 묶여있다면, 외부 연동에이 오래걸릴 수록 커넥션 점유 시간도 늘어남을 생각하자

## 5장. 비동기 연동, 언제 어떻게 써야 할까

- 예시
	- 쇼핑몰에서 주문이 들어오며 판매자에게 푸시 보내기
	- 학습을 완료하면 학생에게 포인트 지급
	- 컨텐츠를 등록할 때 검색 서비스에도 등록
	- 인증 번호를 요청하면 SMS로 인증 메시지 발송

- 구현법
	- 별도 스레드로 실행하기
		- new Thread
		- ThreadPool
		- 스프링에선 `@Async` 애노테이션을 이용한 비동기 실행
	- 메시징 시스템 이용하기
		- 서로 영향을 주지 않음
		- 메시징 시스템이 중간에서 메시지를 보관하는 버퍼역할을 할 수 있음
		- 확장이 용이하다
		- Kafka, RabbitMQ, Redis pub/sub
		- Kafka
			- 높은 처리량 (초당 수십만 ~ 수백만)
			- 수평 확장이 용이, 브로커, 파티션, 컨슈머를 늘리면 됨
			- 메시지를 파일에 보관하기 때문에 유실되지 않음
			- 1개의 토픽이 여러 파티션을 가질 수 있고, 파티션 단위로 순서 보장
			- 컨슈머는 언제든 메시지를 재처리할 수 있음
			- 풀 모델을 사용, 컨슈머가 브로커에서 메시지를 읽어 가는 방식
		- RabbitMQ
			- 클러스터를 통해 처리량을 높일 수 있음
			- 메모리에만 메시지를 보관하는 설정 시, 메시지 유실 가능성 있음
			- 메시지는 큐에 등록된 순서대로 컨슈머에게 전송
			- 메시지가 컨슈머에 전달됬는지 확인하는 기능이 있음
			- 푸시 모델을 사용, 브로커가 컨슈머에게 메시지를 전송한다.
				- 컨슈머의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하
			- AMQP, STOMP 등 여러 프로토콜을 지원, pub/sub 패턴, request/response, point to point 패턴을 지원
		- Redis pub/sub
			- 메모리를 사용하여 지연 시간이 짧다
			- 구독자가 없으면 메시지 유실
			- 영구 메시지를 지원하지 않음 (기본적으로)
		- 메시지 퍼블리셔 고려 사항
			- 메시지 유실
				- 무시
				- 재시도
				- 실패 로그를 남김
				- 트랜잭션이 끝난 뒤에 메시지를 전송해야함
		- 메시지 컨슈머 고려 사항
			- 같은 데이터를 가진 메시지를 두 번 받음
			- 메시지 처리 과정에서 오류 발생하여 재수신
	- 트랜잭션 아웃박스 패턴 사용하기
		- 트랜잭션에서 아웃박스 테이블에 메시지 데이터 저장 후 커밋
		- 메시지 처리기가 루프를 돌면서 메시지 처리
	- 배치로 연동하기
		- 생산자에 파일 업로드
		- 생산자가 파일 다운로드
	- CDC 이용하기 (Change Data Capture)
		- Oracle, MySQL 같은 DBMS는 데이터가 변경될 때, 변경내용을 통지하는 기능을 제공함
		- DB는 커밋된 데이터만 변경된 순서에 맞게 전달
		- 단순히 DB 간에 데이터를 복제할 목적으로도 사용가능
		- 

- 글로벌 트랜잭션
	- 여러 자원(여러 DB)에 대한 변경을 한 트랜잭션으로 묶어서 처리 가능
	- 2 페이즈 커밋
	- 커밋 과정이 길어지는 만큼 동시에 처리할 수 있는 요청이 줄어들 수 있음

- 궁극적 일관성 (Eventual consistency)
	- 최종적 일관성, 결과적 일관성
	- 두 데이터 저장소 간의 일관성을 보장하긴 하지만, 일정 시간이 지난 후에야 일관성이 맞춰진다는 특징
	- 일시적으로는 데이터 불일치가 발생할 수 있음

## 6장. 동시성, 데이터가 꼬이기 전에 잡아야 한다

- 프로세스 수준에서의 동시 접근 제어
	- 잠금을 이용한 접근 제어
		- Mutex (mutual exclusion) - 잠금을 부르는 다른 용어
			- Go - Mutex
			- Java - Lock
		- Java - ReentrantLock
		- 세마포어 (semaphore)
			- 동시에 실행할 수 있는 스레드 수 제한
			- 외부 서비스에 대한 동시 요청을 최대 5개로 제한하고 싶을 때 사용할 수 있음
			- Java - Permit
			- Go - Weight
		- 읽기 쓰기 잠금 (ReentrantReadWriteLock)
			- 쓰기 잠금은 한 번에 한 스레드만 구할 수 있음
			- 읽기 잠금은 한 번에 여러 스레드가 구할 수 있음
			- 한 스레드가 쓰기 잠금을 획득하면, 쓰기 잠금이 해제될 때 까지 읽기 잠금을 구할 수 없음
			- 읽기 잠금을 획득한 모든 스레드가 읽기 잠금을 해제할 때 까지 쓰기 잠금을 구할 수 없음
			- 여러 스레드가 계속 요청하여, 쓰기 잠금을 영원히 획득하지 못하는 것은 어떻게 방지?
				- StampedLock
		- 원자적 타입 사용
			- AtomicInteger (락보다 성능이 빠름, CPU의 CAS 연산 사용)
				- CAS - Compare and Swap
		- 동시성 지원 컬렉션 사용
			- ConcurrentHashMap
			- Collections.synchronizedMap() => 내부적으로 synchronized로 처리됨
				- 자바 23 이전 버전에서 가상 스레드 사용 시, 성능에 문제가 있음
		- 불변값 사용
			- CopyOnWriteArrayList - 요소를 추가하거나 삭제할 때마다 매번 새로운 리스트를 생성해서 반환

- DB와 동시성
	- 비관적 잠금, Pessimistic, 선점
		- 실패할 가능성이 높음
		- 동시성 문제를 해결하기 위해, 한 번에 1개의 클라이언트만 접근할 수 있도록하는 잠금을 사용해야할 경우
		- 데이터에 먼저 접근한 트랜잭션이 잠금을 획득하는 방식
		- `select * from table_a where condition for update`
			- 레코드를 조회하면서, 잠금을 획득
			- 한 트랜잭션이 레코드에 대한 잠금을 획득하는 경우, 잠금을 해제할 때까지 다른 트랜잭션은 동일한 레코드에 대한 잠금을 획득할 수 없음
	- 낙관적 잠금, Optimistic
		- 값을 비교하는 방식으로 동시성 문제에 대응
		- 명시적으로 잠금을 사용하지 않음
		- 데이터를 조회한 시점의 값과 수정하려는 시점의 값이 같은지 비교하는 방식으로 동시성 문제를 처리
		- 보통 정수 타입의 version 컬럼을 사용함
	- 트랜잭션 중간에 외부 연동이 포함되어있다면, 선점 잠금을 고려하자
	- 증분 쿼리를 활용하여 DB 단에서 원자적인 연산을 처리
		- DB에서 지원하는지 확인해야 함

- 분산 잠금
	- 레디스를 활용한 분산 잠금

- 잠금 사용 시 주의 사항
	- 잠금을 획득하고 로직을 수행한뒤에는 반드시 잠금을 해제해야 함
	- 잠금을 획득하기 위한 대기시간을 지정하기
	- 데드락 피하기
		- 2개 이상의 자원에 잠금을 획득할 때에는, 데드락을 주의하자
		- 지정한 순서대로 잠금을 획득하도록 하자

## 7장. IO 병목, 어떻게 해결하지

- 스레드를 1만개 생성하는 것만으로 사용하는 메모리는 10G에 육박한다..
- 동시에 실행되는 스레드가 증가하면 컨텍스트 스위칭에 사용되는 시간도 증가한다..

- 트래픽이 증가하면 자원 효율이 떨어지는 이유
	- IO 대기와 컨텍스트 스위칭에 따른 CPU 낭비
	- 요청마다 스레드를 할당함으로써 메모리 사용량이 높음

- 가상 스레드나 고루틴 같은 경량 스레드 사용
- 논블로킹 또는 비동기 IO 사용

### 가상 스레드로 자원 효율 높이기

- 자바 - 가상 스레드
- Go - 고루틴

- OS가 관리하는 스레드가 아닌 JVM 같은 언어의 런타임이 관리하는 스레드
	- 런타임이 OS 스레드로 실행할 경량 스레드를 스케줄링한다.
	- 자바
		- OS 스레드 - 플랫폼 스레드 - 경량 스레드 (1:N) 관계를 가짐
		- 최대 생성 가능한 플랫폼 스레드 수의 기본값 256
		- 스래드의 기본 스택 크기가 1MB로 가정 시, 스레드가 1만개라면 10,000MB = 약 9.8GB의 메모리가 필요함
		- 가상 스레드는 수백 바이트에서 수십 KB의 힙메모리를 사용함 + 플랫폼 스레드 8개라면 = 28MB로도 해결 가능함
		- 가상 스레드는 생성시간도 훨씬 적게 걸림

### 논블로킹 IO로 성능 더 높이기

- 사용자가 폭발적으로 증가하면 어느 순간 경량 스레드로도 한계가 온다
- 이때는 서버의 IO 구현방식을 구조적으로 변경해야 한다.

- 논블로킹 IO
	- 입출력이 끝날 때까지 스레드가 대기하지 않는다.
	- 동시 접속하는 클라이언트가 증가해도 스레드 개수는 일정하게 유지되므로 같은 메모리로 더 많은 클라이언트 연결을 처리할 수 있다.
	- 채널들을 N개의 그룹으로 나누고, 각 그룹마다 스레드를 생성한다.
		- 연결 연산 수행 스레드 1개
		- 읽기 연산 스레드 코어 수 만큼


- 리액터 패턴
	- 동시에 들어오는 여러 이벤트를 처리하기 위한 이벤트 처리 방법
	- 크게 2요소로 구분된다.
		- 리액터
			- 이벤트가 발생할 때 까지 대기
			- 이벤트가 발생하면 알맞은 핸들러에 이벤트 전달
			- 이벤트 루프라고 부르기도 함
		- 핸들러
			- 필요한 로직 수행
	- Netty, Nginx, Node.js 등의 프레임워크나 서버는 리액터 패턴을 적용하고 있음
		- Netty
			- 여러 개의 이벤트 루프를 생성해서 멀티 코어를 활용
		- Node.js
			- 이벤트 루프 외에 별도 스레드 풀을 사용해서 CPU 중심 작업이나 블로킹 연산을 동시에 처리

### 언제 어떤 방법을 택할까

- 논블로킹 IO나 가상 스레드를 적용할 때에는 다음을 검토하자
	- 문제가 있는가?
	- 문제가 있다면 네트워크 IO 관련 성능 문제인가?
	- 구현 변경이 가능한가?

## 8장. 실무에서 꼭 필요한 보안 지식

- 인증 authentication - 사용자가 누구인지 확인
- 인가 authorization - 사용자에게 자원에 접근할 수 있는 권한 부여

- 토큰 보안
	- 토큰 유효 시간 제한
		- 토큰 생성시점 기준으로 제한 시간
		- 마지막 접근 시간 기준으로 제한 시간