
## 2장. 느려진 서비스, 어디부터 봐야할까

- 파일을 읽을 때에는 스트림을 사용하여, 메모리를 최적화 하자
- 응답 데이터 압축
	- gzip
	- brotli (?)
	- Accept-Encoding 헤더에 압축 알고리즘 정의
- 정적 자원 캐시
	- Cache-Control 헤더에 명시
		- 유저의 로컬 캐시에 보관

## 3장.  성능을 좌우하는 DB 설계와 쿼리

- 게시물 본문 검색은 어떻게 구현하는게 좋을까?
	- MySQL FULLTEXT 인덱스 고려
		- ElasticSearch까지 부담될 때..
- 인덱스는 고유한 값이 적은것으로 하는게 좋다.
	- 일자별 데이터는 많아질경우에 월별 파티셔닝 고려
- 게시글 좋아요 수, 조회 수는 어떻게 집계하는게 좋을까?
	- 게시글 Post에 Pessimistic Lock을 잡는방법은 별로 좋지 않은 듯하고
	- 낙관적으로 Locking을 사용하여 좋아요 수를, 늘리고 계속하여 재시도하는 방식으로 처리하는게 낫지 않을까?

- APM 사용
	- 응답 시간 분포를 시각적으로 표시

- 오래된 데이터 삭제 및 분리 보관
	- MySQL에도 단편화가 발생하나?

- 쿼리 타임아웃 설정
	- JPA에서 어떻게 처리?

- SELECT를 반드시 Replica에서 읽으면 안되는 경우도 처리해야한다
	- 상태 변경이 일어난 데이터를 Replica에서 처리할 경우 곤란해질 수 있음
	- 데이터 정합성 불일치

- 타입이 다른 컬럼 조인 주의
	- 게임 도메인에선 그럴일이 거의 없긴 했는데.. 테이블 설계가 잘못된 건 아닐까

- MySQL 테이블 변경
	- 새 테이블 생성
	- 원본 테이블의 데이터 복사
	- 새 테이블로 대체
		- 이 정도로 변경되는 데이터는 미리 수행시간을 측정해서 처리를 고민할듯
		- 테이블 변경에 대한 수행시간 측정은 어떻게 하지?
		- 테이블 변경이 너무 오래걸린다면 중간에 취소해도 괜찮나?
			- 위 흐름이면 가능해보인다..

- 적절한 DB 커넥션 수는?
	- 소켓통신을 위한 소켓을 열어야하는 것이므로 관련된 자원을 안정적으로 유지할 정도만..?

## 4장. 외부 연동이 문제일 때 살펴봐야 할 것들

- 연동하는 서비스에 장애가 발생하면 우리 서비스도 영향을 받는다
	- 완전히 차단하기는 어려우나, 영향을 줄이는 방법을 고민해볼 수 있다.
	- 타임아웃
		- 타임아웃이 발생했으나, 정상적으로 처리되버린 경우는 어떻게..?
		- 연결 타임아웃
			- 3 ~ 5초
		- 읽기 타임아웃
			- 5 ~ 30초 정도 설정하면서 추이를 보자
	- 재시도
		- 단순 조회 기능
		- 연결 타임아웃
		- 멱등성을 가진 변경 기능
			- 멱등성 키등을 통해서, 이미 변경된 값이면 캐쉬된 응답을 내려준다거나.. 처리되있는 경우에만 가능
		- 1~2번 정도의 재시도가 적절
			- 아무리 재시도해도 성공하지 못할 수도 있으므로..
			- 근본적인 문제를 해결하는게 좋다.
	- 연동 서비스가 받아낼 수 있는 요청 수보다 많이 요청하지 않고 에러리턴
		- 503 - 서비스 일시적 장애 에러 코드 
		- 벌크헤드 패턴
	- 서킷 브레이커
		- 닫힘 - 서비스 가능 상태
		- 열림 - 에러 상태
		- 반열림 - 에러 상태에서 어느정도 지나면 반열림 상태가 됨, 일부 요청에 한해 시도
			- 해당 기간동안 성공 시, 닫힘 상태가 됨
			- fast fail

- 외부 연동과 DB 연동
	- 외부 연동 실패 => 트랜잭션 롤백
	- 외부 연동 성공 but DB 연동 실패 => 트랜잭션 롤백

- 트랜잭션을 롤백했는데, 외부 서비스가 실제로 성공
	- 일정 주기로 데이터가 일치하는지 확인 후 보정
	- 성공 확인 API 호출 or 취소 API 호출 (보상 트랜잭션?)
		- 이 API 호출에도 타임아웃이 발생할 수 있음을 고려해야 함

- 외부 연동이 느려질 때 DB 커넥션 풀 문제
	- 외부 연동과 트랜잭션이 묶여있다면, 외부 연동에이 오래걸릴 수록 커넥션 점유 시간도 늘어남을 생각하자

## 5장. 비동기 연동, 언제 어떻게 써야 할까

- 예시
	- 쇼핑몰에서 주문이 들어오며 판매자에게 푸시 보내기
	- 학습을 완료하면 학생에게 포인트 지급
	- 컨텐츠를 등록할 때 검색 서비스에도 등록
	- 인증 번호를 요청하면 SMS로 인증 메시지 발송

- 구현법
	- 별도 스레드로 실행하기
		- new Thread
		- ThreadPool
		- 스프링에선 `@Async` 애노테이션을 이용한 비동기 실행
	- 메시징 시스템 이용하기
		- 서로 영향을 주지 않음
		- 메시징 시스템이 중간에서 메시지를 보관하는 버퍼역할을 할 수 있음
		- 확장이 용이하다
		- Kafka, RabbitMQ, Redis pub/sub
		- Kafka
			- 높은 처리량 (초당 수십만 ~ 수백만)
			- 수평 확장이 용이, 브로커, 파티션, 컨슈머를 늘리면 됨
			- 메시지를 파일에 보관하기 때문에 유실되지 않음
			- 1개의 토픽이 여러 파티션을 가질 수 있고, 파티션 단위로 순서 보장
			- 컨슈머는 언제든 메시지를 재처리할 수 있음
			- 풀 모델을 사용, 컨슈머가 브로커에서 메시지를 읽어 가는 방식
		- RabbitMQ
			- 클러스터를 통해 처리량을 높일 수 있음
			- 메모리에만 메시지를 보관하는 설정 시, 메시지 유실 가능성 있음
			- 메시지는 큐에 등록된 순서대로 컨슈머에게 전송
			- 메시지가 컨슈머에 전달됬는지 확인하는 기능이 있음
			- 푸시 모델을 사용, 브로커가 컨슈머에게 메시지를 전송한다.
				- 컨슈머의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하
			- AMQP, STOMP 등 여러 프로토콜을 지원, pub/sub 패턴, request/response, point to point 패턴을 지원
		- Redis pub/sub
			- 메모리를 사용하여 지연 시간이 짧다
			- 구독자가 없으면 메시지 유실
			- 영구 메시지를 지원하지 않음 (기본적으로)
		- 메시지 퍼블리셔 고려 사항
			- 메시지 유실
				- 무시
				- 재시도
				- 실패 로그를 남김
				- 트랜잭션이 끝난 뒤에 메시지를 전송해야함
		- 메시지 컨슈머 고려 사항
			- 같은 데이터를 가진 메시지를 두 번 받음
			- 메시지 처리 과정에서 오류 발생하여 재수신
	- 트랜잭션 아웃박스 패턴 사용하기
		- 트랜잭션에서 아웃박스 테이블에 메시지 데이터 저장 후 커밋
		- 메시지 처리기가 루프를 돌면서 메시지 처리
	- 배치로 연동하기
		- 생산자에 파일 업로드
		- 생산자가 파일 다운로드
	- CDC 이용하기 (Change Data Capture)
		- Oracle, MySQL 같은 DBMS는 데이터가 변경될 때, 변경내용을 통지하는 기능을 제공함
		- DB는 커밋된 데이터만 변경된 순서에 맞게 전달
		- 단순히 DB 간에 데이터를 복제할 목적으로도 사용가능
		- 

- 글로벌 트랜잭션
	- 여러 자원(여러 DB)에 대한 변경을 한 트랜잭션으로 묶어서 처리 가능
	- 2 페이즈 커밋
	- 커밋 과정이 길어지는 만큼 동시에 처리할 수 있는 요청이 줄어들 수 있음

- 궁극적 일관성 (Eventual consistency)
	- 최종적 일관성, 결과적 일관성
	- 두 데이터 저장소 간의 일관성을 보장하긴 하지만, 일정 시간이 지난 후에야 일관성이 맞춰진다는 특징
	- 일시적으로는 데이터 불일치가 발생할 수 있음

## 6장. 동시성, 데이터가 꼬이기 전에 잡아야 한다

- 프로세스 수준에서의 동시 접근 제어
	- 잠금을 이용한 접근 제어
		- Mutex (mutual exclusion) - 잠금을 부르는 다른 용어
			- Go - Mutex
			- Java - Lock
		- Java - ReentrantLock
		- 세마포어 (semaphore)
			- 동시에 실행할 수 있는 스레드 수 제한
			- 외부 서비스에 대한 동시 요청을 최대 5개로 제한하고 싶을 때 사용할 수 있음
			- Java - Permit
			- Go - Weight
		- 읽기 쓰기 잠금 (ReentrantReadWriteLock)
			- 쓰기 잠금은 한 번에 한 스레드만 구할 수 있음
			- 읽기 잠금은 한 번에 여러 스레드가 구할 수 있음
			- 한 스레드가 쓰기 잠금을 획득하면, 쓰기 잠금이 해제될 때 까지 읽기 잠금을 구할 수 없음
			- 읽기 잠금을 획득한 모든 스레드가 읽기 잠금을 해제할 때 까지 쓰기 잠금을 구할 수 없음
			- 여러 스레드가 계속 요청하여, 쓰기 잠금을 영원히 획득하지 못하는 것은 어떻게 방지?
				- StampedLock
		- 원자적 타입 사용
			- AtomicInteger (락보다 성능이 빠름, CPU의 CAS 연산 사용)
				- CAS - Compare and Swap
		- 동시성 지원 컬렉션 사용
			- ConcurrentHashMap
			- Collections.synchronizedMap() => 내부적으로 synchronized로 처리됨
				- 자바 23 이전 버전에서 가상 스레드 사용 시, 성능에 문제가 있음
		- 불변값 사용
			- CopyOnWriteArrayList - 요소를 추가하거나 삭제할 때마다 매번 새로운 리스트를 생성해서 반환

- DB와 동시성
	- 비관적 잠금, Pessimistic, 선점
		- 실패할 가능성이 높음
		- 동시성 문제를 해결하기 위해, 한 번에 1개의 클라이언트만 접근할 수 있도록하는 잠금을 사용해야할 경우
		- 데이터에 먼저 접근한 트랜잭션이 잠금을 획득하는 방식
		- `select * from table_a where condition for update`
			- 레코드를 조회하면서, 잠금을 획득
			- 한 트랜잭션이 레코드에 대한 잠금을 획득하는 경우, 잠금을 해제할 때까지 다른 트랜잭션은 동일한 레코드에 대한 잠금을 획득할 수 없음
	- 낙관적 잠금, Optimistic
		- 값을 비교하는 방식으로 동시성 문제에 대응
		- 명시적으로 잠금을 사용하지 않음
		- 데이터를 조회한 시점의 값과 수정하려는 시점의 값이 같은지 비교하는 방식으로 동시성 문제를 처리
		- 보통 정수 타입의 version 컬럼을 사용함
	- 트랜잭션 중간에 외부 연동이 포함되어있다면, 선점 잠금을 고려하자
	- 증분 쿼리를 활용하여 DB 단에서 원자적인 연산을 처리
		- DB에서 지원하는지 확인해야 함

- 분산 잠금
	- 레디스를 활용한 분산 잠금

- 잠금 사용 시 주의 사항
	- 잠금을 획득하고 로직을 수행한뒤에는 반드시 잠금을 해제해야 함
	- 잠금을 획득하기 위한 대기시간을 지정하기
	- 데드락 피하기
		- 2개 이상의 자원에 잠금을 획득할 때에는, 데드락을 주의하자
		- 지정한 순서대로 잠금을 획득하도록 하자

## 7장. IO 병목, 어떻게 해결하지

- 스레드를 1만개 생성하는 것만으로 사용하는 메모리는 10G에 육박한다..
- 동시에 실행되는 스레드가 증가하면 컨텍스트 스위칭에 사용되는 시간도 증가한다..

- 트래픽이 증가하면 자원 효율이 떨어지는 이유
	- IO 대기와 컨텍스트 스위칭에 따른 CPU 낭비
	- 요청마다 스레드를 할당함으로써 메모리 사용량이 높음

- 가상 스레드나 고루틴 같은 경량 스레드 사용
- 논블로킹 또는 비동기 IO 사용

### 가상 스레드로 자원 효율 높이기

- 자바 - 가상 스레드
- Go - 고루틴

- OS가 관리하는 스레드가 아닌 JVM 같은 언어의 런타임이 관리하는 스레드
	- 런타임이 OS 스레드로 실행할 경량 스레드를 스케줄링한다.
	- 자바
		- OS 스레드 - 플랫폼 스레드 - 경량 스레드 (1:N) 관계를 가짐
		- 최대 생성 가능한 플랫폼 스레드 수의 기본값 256
		- 스래드의 기본 스택 크기가 1MB로 가정 시, 스레드가 1만개라면 10,000MB = 약 9.8GB의 메모리가 필요함
		- 가상 스레드는 수백 바이트에서 수십 KB의 힙메모리를 사용함 + 플랫폼 스레드 8개라면 = 28MB로도 해결 가능함
		- 가상 스레드는 생성시간도 훨씬 적게 걸림

### 논블로킹 IO로 성능 더 높이기

- 사용자가 폭발적으로 증가하면 어느 순간 경량 스레드로도 한계가 온다
- 이때는 서버의 IO 구현방식을 구조적으로 변경해야 한다.

- 논블로킹 IO
	- 입출력이 끝날 때까지 스레드가 대기하지 않는다.
	- 동시 접속하는 클라이언트가 증가해도 스레드 개수는 일정하게 유지되므로 같은 메모리로 더 많은 클라이언트 연결을 처리할 수 있다.
	- 채널들을 N개의 그룹으로 나누고, 각 그룹마다 스레드를 생성한다.
		- 연결 연산 수행 스레드 1개
		- 읽기 연산 스레드 코어 수 만큼


- 리액터 패턴
	- 동시에 들어오는 여러 이벤트를 처리하기 위한 이벤트 처리 방법
	- 크게 2요소로 구분된다.
		- 리액터
			- 이벤트가 발생할 때 까지 대기
			- 이벤트가 발생하면 알맞은 핸들러에 이벤트 전달
			- 이벤트 루프라고 부르기도 함
		- 핸들러
			- 필요한 로직 수행
	- Netty, Nginx, Node.js 등의 프레임워크나 서버는 리액터 패턴을 적용하고 있음
		- Netty
			- 여러 개의 이벤트 루프를 생성해서 멀티 코어를 활용
		- Node.js
			- 이벤트 루프 외에 별도 스레드 풀을 사용해서 CPU 중심 작업이나 블로킹 연산을 동시에 처리

### 언제 어떤 방법을 택할까

- 논블로킹 IO나 가상 스레드를 적용할 때에는 다음을 검토하자
	- 문제가 있는가?
	- 문제가 있다면 네트워크 IO 관련 성능 문제인가?
	- 구현 변경이 가능한가?

## 8장. 실무에서 꼭 필요한 보안 지식

- 인증 authentication - 사용자가 누구인지 확인
- 인가 authorization - 사용자에게 자원에 접근할 수 있는 권한 부여

- 토큰 보안
	- 토큰 유효 시간 제한
		- 토큰 생성시점 기준으로 제한 시간
		- 마지막 접근 시간 기준으로 제한 시간

- 권한 부여
	- Role Based Access Control
	- 사용자별 권한 부여 방식
	- 속성기반 접근제어 (IP에 따라서 특정 기능의 접근 허용 등..)

### 감사 로그 (audit log) 남기기

- 사용자의 로그인 / 로그아웃 내역
- 암호 초기화 등 설정 변경 내역
- 환자 기록을 조회한 의료진 정보
- 계약서의 수정 이력

### 비정상 접근 처리

- 평소와 다른 장소에서 로그인
- 평소와 다른 기기에서 로그인
- 로그인에 여러 차례 실패

## 9. 서버 개발자가 알면 좋은 지식

- 프로세스 종료
	- kill - 15 (프로세스에 TERM 신호를 보냄)
		- 스프링 빈의 제거 처리를 하는 작업 수행
		- kill -9 실행전에 먼저 수행해보자
	- kill -9 : 프로세스 강제 종료
		- 프로그램이 종료할 때 수행하는 정리작업을 할 수 없음 (graceful shutdown이 동작하지 않는건가..?)

- 백그라운드 프로세스
	- 리눅스에서 프로세스를 백그라운드로 실행하려면 명령어 뒤에 &를 붙이면 됨
		- java -Dserver.port=9090 -jar server.jar &
	- 터미널을 종료해도 백그라운드 프로세스가 계속 실행되게 하려면 nohup과 &를 사용함
		- nohup java -Dserver.port=9090 -jar server.jar &
		- nohup = No Hang Up, 터미널 연결이 끊길 때 전송되는 HUP 시그널이 프로세스에 전달되지 않게 함
		- nohup java -Dserver.port=9090 -jar server.jar > server.log 2>&1 &
		- 2 : 표준 오류
		- > : 리디렉션 연산
		- &1 : 표준 출력
		- 표준 오류를, 표준 출력과 동일한 경로로 전달하라는 의미

- alias 등록하기
	- 자주 사용하는 명령어를 별칭으로 등록
	- `alias cdweb = 'cd /var/www/html'`
	- `.bash_profile` : 사용자가 로그인할 떄 한 번 실행됨, PATH 처럼 전체 세션에 필요한 환경 변수 설정
	- `.bashrc` 새로운 bash 셀을 시작하거나, 터미널 창을 열 떄 실행됨. 주로 alias 와 같이 각 세션마다 적용할 설정을 이 파일에 지정한다.

### nc 명령어로 연결 확인하기

- 네트워크 연결이 정상적으로 이루어지는지 확인할 필요가 있을 때
	- nc -z -v www.naver.com 443
- 포트로 클라이언트 연결을 기다리고 있는지 확인해야할 떄
	- netstat -lputn
	- -l : 리스닝 서버 소켓을 출력
	- -p : 소켓을 사용하는 PID/프로그램 이름을 출력
	- -u : UDP 소켓을 출력
	- - t : TCP 소켓을 출력
	- -n : 포트나 주소를 숫자로 출력

## 10장. 모르면 답답해지는 네트워크 기초

- 노드, 네트워크, 라우터
	- 노드 : 데이터를 송수신하는 모든 장치
	- 네트워크 : 각 노드가 서로 데이터를 주고 받기 위해 연결된 시스템
	- 라우터 : 네트워크 간에 패킷을 전송하는 역할 (서로 다른 네트워크에 속한 노드는 직접 연결해서 패킷을 송수신할 수 없음)

- IP 주소, 도메인
	- IP 주소 : 네트워크에서 각 노드를 구분하기 위해 사용하는 주소
	- 도메인 이름 : IP 주소에 기억하기 쉬운 이름을 붙임 (naver.com 등)
	- hosts 파일
		- 호스트 이름과 IP 주소에 대한 매핑을 정의한 파일
		- DNS 서버 보다, 우선됨
		- localhost 설정도 이 파일에 정의되어 있음

- 공인 IP, 사설 IP
	- 사설 IP : 네트워크 내부에만 적용되는 주소
		- 다음의 3가지 범위로 존재
		- 192.168.x.x 
		- 10.x.x.x
		- 172.16.x.x ~ 172.31.x.x

- NAT : Network Address Translation : 네트워크 주소 변환
	- 내부에서 사용하는 사설 IP와 인터넷에서 사용하는 공인 IP 주소 간의 변환이 필요할 때 변환을 담당
	- 주로 인터넷에 연결된 라우터 같은 네트워크 장비가 담당
		- 소스 IP의 주소를 변환한다고 해서 이를 SNAT(Source NAT)이라고 한다.
		- 공인 IP로 들어온 패킷의 목적지를 사설 IP로 변환하기도 함 이를 DNAT(Destination NAT)이라고 한다.

- VPN
	- 가상 사설 네트워크
	- 인터넷과 같은 공용 네트워크에서 서로 다른 네트워크 간에 암호화된 연결을 제공
	- 두 네트워크는 마치 하나의 사설 네트워크에 존재하는 것처럼 연결될 수 있음


### 프로토콜과 TCP, UDP, QUIC

- 애플리케이션 계층 - HTTP, FTP, SMTP
- 전송 계층 - TCP, UDP
- 네트워크 계층 - IP


- TCP : 연결 기반 프로토콜
	- 연결 : 3-way handshake
		- 클라이언트 -> 서버 : syn
		- 서버 -> 클라이언트 : syn-ack
		- 클라이언트 -> 서버 : ack
	- 패킷 순서 보장
	- 패킷이 유실될 경우 재전송

- UDP : 연결 과정 없이 데이터 전송
	- 데이터가 정상적으로 전송됐는지 알 수 없음
	- 순서를 보장하지 않음
	- 속도가 중요하거나, 일부 데이터가 유실되더라도 문제되지 않는 통신에 주로 사용
	- DNS, VoIP, 게임

- QUIC : UDP 기반, TCP 연결 관리 기능을 QUIC 프로토콜 수준에서 제공
	- 데이터에 연결 ID 포함
		- 두 노드 간의 연결 유지
	- 혼잡 제어, 패킷 유실 복구와 같은 기능 제공
	- TLS 통합
		- 기본적으로 암호화되어 전송
	- 멀티플렉싱 지원
		- 한 연결에서 여러 스트림 동시에 처리
	- HTTP/3

- TCP 연결은 65535개가 한계인가?
	- 이론적으로는 2^96 개의 연결 생성 가능
		- 2^16 (로컬포트) x 2^32 (원격IP) x 2^16 (원격포트) = 2^44
	- 하나의 로컬 IP에서 특정 원격 IP의 1개 포트에 연결할 수 있는 TCP 연결 개수가 65535
	- 이론적으로 그렇지만, 실제로 생성할 수 있는 연결 개수는 OS 설정 (파일 디스크립터 개수, 포트 범위 설정 등)에 따라 제약을 받는다.

## 11장. 자주 쓰는 서버 구조와 설계 패턴

- MVC (Model View Controller)
- 계층형 아키텍쳐 (Layered Architecture)
	- 하위 계층은 상위 계층에 대한 의존을 갖지 않음
	- 오직 상위 계층에서 하위 계층으로의 의존만 허용
	- 웹에선 다음의 계층 구조로
		- presentation (or ui)
		- application
		- domain
		- infra (or persistence)


### DDD와 전술 패턴

- 로직이 복잡한 도메인을 구현할 때 DDD에 소개된 패턴을 사용해보자
	- 엔티티 
		- 고유의 식별자를 가지며, 각 식별자로 구분 됨
		- 내부 상태가 바뀌어도 식별자는 바뀌지 않음
	- 밸류
		- 고유의 식별자를 갖지 않으며, 개념적인 값을 표현
		- 금액, 배송 주소 등
		- 값은 불변으로 구현하는 것을 추천
	- 애그리거트
		- 관련된 객체를 묶어 하나의 개념적인 단위를 표현
		- 예시) 주문 애그리거트 - Order Entity, OrderLine Values, Shipping Address Values
	- 레포지터리
		- 도메인 객체를 물리적인 저장소와 연결
		- 도메인 객체 저장 및 조회 인터페이스 제공
		- 애그리거트 단위로 존재
	- 도메인 서비스
		- 특정한 애그리거트에 속하지 않은 로직 구현
		- 외부 연동이 필요한 도메인 로직도 도메인 서비스를 사용해서 표현
	- 도메인 이벤트
		- 도메인 내에서 발생한 이벤트 표현

- 바운디드 컨텍스트
	- 도메인 간의 경계 설정

- CQRS 패턴 (Command Query Responsibility Segregation)
	- 명령과 조회에서 사용하는 모델을 분리하는 패턴
	- 명령과 조회 모델이 분리됨으로, 상호 영향 문제를 최소화
		- 조회 전용 모델에 캐시를 적용하거나, DB를 확장할 수도 있을 것
	- 모델이 복잡한 경우에 사용하면 이점이 있을 가능성이 있다



## 부록A. 처음 해보는 성능 테스트를 위한 기본 정리

- 내가 만든 서버가 어느 정도 트래픽을 감당하는지 확인하려면 실제 테스트를 해야함 => 성능 테스트
- 성능 테스트는 일반적으로 특정 작업 부하 상태에서 응답성과 안정성 측면에서 시스템이 어떻게 동작하는지를 확인하기 위해 수행하는 테스트 관행
	- 응답 시간, 처리량, 자원 사용량(CPU, 메모리)등을 주로 측정한다.

- 성능 테스트의 종류
	- 부하 테스트
		- 특정한 예상 부하에서 시스템이 어떻게 동작하는지 확인
		- 주요 기능의 응답 시간과 처리량 등의 성능 지표 확인
		- 병목을 파악하는데 도움
	- 스트레스 테스트
		- 시스템의 최대 성능을 확인하기 위한 테스트
		- 예상을 뛰어넘는 부하가 발생했을 때, 시스템이 어디까지 성능을 낼 수 있을지 확인
	- 지속 부하 테스트
		- 시스템이 지속적인 부하를 견딜 수 있는지 검증
		- 장시간 동안 일정 수준의 부하를 주어, 성능 저하가 발생하는지 확인
		- 메모리 누수 탐지
	- 스파이크 테스트
		- 급격하게 트래픽이 변화할 때, 시스템의 반응성과 안정성을 검증하는 테스트
		- 순간적으로 트래픽이 급증했을 때, 성능 저하나 실패가 발생하는지 확인

### 포화점과 버클존

- 성능 테스트의 일반적인 방식 낮은 부하 => 높은 부하
	- 동시 사용자 수 100 => 200 => 300 ...