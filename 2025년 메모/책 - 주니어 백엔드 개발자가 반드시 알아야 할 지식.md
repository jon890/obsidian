
## 2장. 느려진 서비스, 어디부터 봐야할까

- 파일을 읽을 때에는 스트림을 사용하여, 메모리를 최적화 하자
- 응답 데이터 압축
	- gzip
	- brotli (?)
	- Accept-Encoding 헤더에 압축 알고리즘 정의
- 정적 자원 캐시
	- Cache-Control 헤더에 명시
		- 유저의 로컬 캐시에 보관

## 3장.  성능을 좌우하는 DB 설계와 쿼리

- 게시물 본문 검색은 어떻게 구현하는게 좋을까?
	- MySQL FULLTEXT 인덱스 고려
		- ElasticSearch까지 부담될 때..
- 인덱스는 고유한 값이 적은것으로 하는게 좋다.
	- 일자별 데이터는 많아질경우에 월별 파티셔닝 고려
- 게시글 좋아요 수, 조회 수는 어떻게 집계하는게 좋을까?
	- 게시글 Post에 Pessimistic Lock을 잡는방법은 별로 좋지 않은 듯하고
	- 낙관적으로 Locking을 사용하여 좋아요 수를, 늘리고 계속하여 재시도하는 방식으로 처리하는게 낫지 않을까?

- APM 사용
	- 응답 시간 분포를 시각적으로 표시

- 오래된 데이터 삭제 및 분리 보관
	- MySQL에도 단편화가 발생하나?

- 쿼리 타임아웃 설정
	- JPA에서 어떻게 처리?

- SELECT를 반드시 Replica에서 읽으면 안되는 경우도 처리해야한다
	- 상태 변경이 일어난 데이터를 Replica에서 처리할 경우 곤란해질 수 있음
	- 데이터 정합성 불일치

- 타입이 다른 컬럼 조인 주의
	- 게임 도메인에선 그럴일이 거의 없긴 했는데.. 테이블 설계가 잘못된 건 아닐까

- MySQL 테이블 변경
	- 새 테이블 생성
	- 원본 테이블의 데이터 복사
	- 새 테이블로 대체
		- 이 정도로 변경되는 데이터는 미리 수행시간을 측정해서 처리를 고민할듯
		- 테이블 변경에 대한 수행시간 측정은 어떻게 하지?
		- 테이블 변경이 너무 오래걸린다면 중간에 취소해도 괜찮나?
			- 위 흐름이면 가능해보인다..

- 적절한 DB 커넥션 수는?
	- 소켓통신을 위한 소켓을 열어야하는 것이므로 관련된 자원을 안정적으로 유지할 정도만..?

## 4장. 외부 연동이 문제일 때 살펴봐야 할 것들

- 연동하는 서비스에 장애가 발생하면 우리 서비스도 영향을 받는다
	- 완전히 차단하기는 어려우나, 영향을 줄이는 방법을 고민해볼 수 있다.
	- 타임아웃
		- 타임아웃이 발생했으나, 정상적으로 처리되버린 경우는 어떻게..?
		- 연결 타임아웃
			- 3 ~ 5초
		- 읽기 타임아웃
			- 5 ~ 30초 정도 설정하면서 추이를 보자
	- 재시도
		- 단순 조회 기능
		- 연결 타임아웃
		- 멱등성을 가진 변경 기능
			- 멱등성 키등을 통해서, 이미 변경된 값이면 캐쉬된 응답을 내려준다거나.. 처리되있는 경우에만 가능
		- 1~2번 정도의 재시도가 적절
			- 아무리 재시도해도 성공하지 못할 수도 있으므로..
			- 근본적인 문제를 해결하는게 좋다.
	- 연동 서비스가 받아낼 수 있는 요청 수보다 많이 요청하지 않고 에러리턴
		- 503 - 서비스 일시적 장애 에러 코드 
		- 벌크헤드 패턴
	- 서킷 브레이커
		- 닫힘 - 서비스 가능 상태
		- 열림 - 에러 상태
		- 반열림 - 에러 상태에서 어느정도 지나면 반열림 상태가 됨, 일부 요청에 한해 시도
			- 해당 기간동안 성공 시, 닫힘 상태가 됨
			- fast fail

- 외부 연동과 DB 연동
	- 외부 연동 실패 => 트랜잭션 롤백
	- 외부 연동 성공 but DB 연동 실패 => 트랜잭션 롤백

- 트랜잭션을 롤백했는데, 외부 서비스가 실제로 성공
	- 일정 주기로 데이터가 일치하는지 확인 후 보정
	- 성공 확인 API 호출 or 취소 API 호출 (보상 트랜잭션?)
		- 이 API 호출에도 타임아웃이 발생할 수 있음을 고려해야 함

- 외부 연동이 느려질 때 DB 커넥션 풀 문제
	- 외부 연동과 트랜잭션이 묶여있다면, 외부 연동에이 오래걸릴 수록 커넥션 점유 시간도 늘어남을 생각하자

## 5장. 비동기 연동, 언제 어떻게 써야 할까

- 예시
	- 쇼핑몰에서 주문이 들어오며 판매자에게 푸시 보내기
	- 학습을 완료하면 학생에게 포인트 지급
	- 컨텐츠를 등록할 때 검색 서비스에도 등록
	- 인증 번호를 요청하면 SMS로 인증 메시지 발송

- 구현법
	- 별도 스레드로 실행하기
		- new Thread
		- ThreadPool
		- 스프링에선 `@Async` 애노테이션을 이용한 비동기 실행
	- 메시징 시스템 이용하기
		- 서로 영향을 주지 않음
		- 메시징 시스템이 중간에서 메시지를 보관하는 버퍼역할을 할 수 있음
		- 확장이 용이하다
		- Kafka, RabbitMQ, Redis pub/sub
		- Kafka
			- 높은 처리량 (초당 수십만 ~ 수백만)
			- 수평 확장이 용이, 브로커, 파티션, 컨슈머를 늘리면 됨
			- 메시지를 파일에 보관하기 때문에 유실되지 않음
			- 1개의 토픽이 여러 파티션을 가질 수 있고, 파티션 단위로 순서 보장
			- 컨슈머는 언제든 메시지를 재처리할 수 있음
			- 풀 모델을 사용, 컨슈머가 브로커에서 메시지를 읽어 가는 방식
		- RabbitMQ
			- 클러스터를 통해 처리량을 높일 수 있음
			- 메모리에만 메시지를 보관하는 설정 시, 메시지 유실 가능성 있음
			- 메시지는 큐에 등록된 순서대로 컨슈머에게 전송
			- 메시지가 컨슈머에 전달됬는지 확인하는 기능이 있음
			- 푸시 모델을 사용, 브로커가 컨슈머에게 메시지를 전송한다.
				- 컨슈머의 성능이 느려지면 큐에 과부하가 걸려 전반적으로 성능 저하
			- AMQP, STOMP 등 여러 프로토콜을 지원, pub/sub 패턴, request/response, point to point 패턴을 지원
		- Redis pub/sub
			- 메모리를 사용하여 지연 시간이 짧다
			- 구독자가 없으면 메시지 유실
			- 영구 메시지를 지원하지 않음 (기본적으로)
		- 메시지 퍼블리셔 고려 사항
			- 메시지 유실
				- 무시
				- 재시도
				- 실패 로그를 남김
	- 트랜잭션 아웃박스 패턴 사용하기
	- 배치로 연동하기
	- CDC 이용하기